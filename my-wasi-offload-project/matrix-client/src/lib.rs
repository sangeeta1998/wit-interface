#[allow(warnings)]
mod bindings;


use bindings::Guest;
use bindings::wasi_custom::host_offload::host_allocator;

use crate::bindings::wasi_custom::host_offload::host_allocator::MatrixDimensions;


// Define the component that implements the Guest trait.
struct Component;

// Implement the `Guest` trait for our world (generated by wit-bindgen).
// The trait name is `crate::Client` (matching the world name).
impl Guest for Component {
    fn run_matrix_example() -> Result<(), String> {
        println!("[Client Wasm] Starting matrix example...");

        // Define matrices A and B (e.g., 2x2)
        // A = [[1.0, 2.0], [3.0, 4.0]]
        // B = [[5.0, 6.0], [7.0, 8.0]]
        // C = A x B = [[19.0, 22.0], [43.0, 50.0]]
        let a_data: Vec<f32> = vec![1.0, 2.0, 3.0, 4.0];
        let b_data: Vec<f32> = vec![5.0, 6.0, 7.0, 8.0];
        let dims_a = MatrixDimensions { rows: 2, cols: 2 };
        let dims_b = MatrixDimensions { rows: 2, cols: 2 };

        let a_bytes = f32_vec_to_bytes(&a_data);
        let b_bytes = f32_vec_to_bytes(&b_data);

        // 1. Allocate host buffers
        let handle_a = host_allocator::allocate_buffer(a_bytes.len() as u64)
            .map_err(|e| format!("Failed to allocate for A: {:?}", e))?;
        println!("[Client Wasm] Allocated A, handle: {}", handle_a);

        let handle_b = host_allocator::allocate_buffer(b_bytes.len() as u64)
            .map_err(|e| format!("Failed to allocate for B: {:?}", e))?;
        println!("[Client Wasm] Allocated B, handle: {}", handle_b);

        // 2. Write data to host buffers
        host_allocator::write_to_host(&a_bytes, handle_a, 0)
            .map_err(|e| format!("Failed to write A: {:?}", e))?;
        println!("[Client Wasm] Wrote A data to host");
        host_allocator::register_matrix_dimensions(handle_a, dims_a)
             .map_err(|e| format!("Failed to register dims A: {:?}", e))?;
        println!("[Client Wasm] Registered A dimensions");


        host_allocator::write_to_host(&b_bytes, handle_b, 0)
            .map_err(|e| format!("Failed to write B: {:?}", e))?;
        println!("[Client Wasm] Wrote B data to host");
        host_allocator::register_matrix_dimensions(handle_b, dims_b)
             .map_err(|e| format!("Failed to register dims B: {:?}", e))?;
        println!("[Client Wasm] Registered B dimensions");

        // 3. Perform matrix multiplication
        let handle_c = host_allocator::matrix_multiply_f32(handle_a, handle_b)
            .map_err(|e| format!("Matrix multiplication failed: {:?}", e))?;
        println!("[Client Wasm] Matrix multiplication done. Result C handle: {}", handle_c);

        // 4. Get dimensions of C and read C back
        let dims_c = host_allocator::get_matrix_dimensions(handle_c)
            .map_err(|e| format!("Failed to get C dimensions: {:?}", e))?;
        println!("[Client Wasm] Got C dimensions: {}x{}", dims_c.rows, dims_c.cols);

        let c_byte_len = (dims_c.rows * dims_c.cols * std::mem::size_of::<f32>() as u32) as u64;
        let c_bytes = host_allocator::read_from_host(handle_c, 0, c_byte_len)
            .map_err(|e| format!("Failed to read C: {:?}", e))?;
        println!("[Client Wasm] Read C data from host ({} bytes)", c_bytes.len());

        let c_data = bytes_to_f32_vec(&c_bytes).ok_or("Failed to parse C data".to_string())?;
        println!("[Client Wasm] Result C: {:?}", c_data);

        // Expected: [19.0, 22.0, 43.0, 50.0]
        let expected_c: Vec<f32> = vec![19.0, 22.0, 43.0, 50.0];
        if c_data.iter().zip(expected_c.iter()).all(|(a,b)| (a-b).abs() < f32::EPSILON) {
            println!("[Client Wasm] Matrix multiplication SUCCESSFUL!");
        } else {
            return Err(format!("[Client Wasm] Matrix multiplication FAILED. Expected {:?}, Got {:?}", expected_c, c_data));
        }

        // 5. Free host buffers
        host_allocator::free_buffer(handle_a).map_err(|e| format!("Failed to free A: {:?}", e))?;
        host_allocator::free_buffer(handle_b).map_err(|e| format!("Failed to free B: {:?}", e))?;
        host_allocator::free_buffer(handle_c).map_err(|e| format!("Failed to free C: {:?}", e))?;
        println!("[Client Wasm] Freed all handles.");

        Ok(())
    }
}

fn f32_vec_to_bytes(data: &[f32]) -> Vec<u8> {
    let mut bytes = Vec::with_capacity(data.len() * std::mem::size_of::<f32>());
    for val in data {
        bytes.extend_from_slice(&val.to_ne_bytes());
    }
    bytes
}

fn bytes_to_f32_vec(bytes: &[u8]) -> Option<Vec<f32>> {
    if bytes.len() % std::mem::size_of::<f32>() != 0 {
        return None;
    }
    let mut result = Vec::with_capacity(bytes.len() / std::mem::size_of::<f32>());
    for chunk in bytes.chunks_exact(std::mem::size_of::<f32>()) {
        result.push(f32::from_ne_bytes(chunk.try_into().unwrap()));
    }
    Some(result)
}

bindings::export!(Component with_types_in bindings);