// Generated by `wit-bindgen` 0.41.0. DO NOT EDIT!
// Options used:
//   * runtime_path: "wit_bindgen_rt"
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_run_kv_example_cabi<T: Guest>() -> *mut u8 {
    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
    let result0 = T::run_kv_example();
    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
    match result0 {
        Ok(_) => {
            *ptr1.add(0).cast::<u8>() = (0i32) as u8;
        }
        Err(e) => {
            *ptr1.add(0).cast::<u8>() = (1i32) as u8;
            let vec2 = (e.into_bytes()).into_boxed_slice();
            let ptr2 = vec2.as_ptr().cast::<u8>();
            let len2 = vec2.len();
            ::core::mem::forget(vec2);
            *ptr1.add(2 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len2;
            *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr2
                .cast_mut();
        }
    };
    ptr1
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn __post_return_run_kv_example<T: Guest>(arg0: *mut u8) {
    let l0 = i32::from(*arg0.add(0).cast::<u8>());
    match l0 {
        0 => {}
        _ => {
            let l1 = *arg0.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
            let l2 = *arg0.add(2 * ::core::mem::size_of::<*const u8>()).cast::<usize>();
            _rt::cabi_dealloc(l1, l2, 1);
        }
    }
}
pub trait Guest {
    fn run_kv_example() -> Result<(), _rt::String>;
}
#[doc(hidden)]
macro_rules! __export_world_client_cabi {
    ($ty:ident with_types_in $($path_to_types:tt)*) => {
        const _ : () = { #[unsafe (export_name = "run-kv-example")] unsafe extern "C" fn
        export_run_kv_example() -> * mut u8 { unsafe { $($path_to_types)*::
        _export_run_kv_example_cabi::<$ty > () } } #[unsafe (export_name =
        "cabi_post_run-kv-example")] unsafe extern "C" fn
        _post_return_run_kv_example(arg0 : * mut u8,) { unsafe { $($path_to_types)*::
        __post_return_run_kv_example::<$ty > (arg0) } } };
    };
}
#[doc(hidden)]
pub(crate) use __export_world_client_cabi;
#[cfg_attr(target_pointer_width = "64", repr(align(8)))]
#[cfg_attr(target_pointer_width = "32", repr(align(4)))]
struct _RetArea([::core::mem::MaybeUninit<u8>; 3 * ::core::mem::size_of::<*const u8>()]);
static mut _RET_AREA: _RetArea = _RetArea(
    [::core::mem::MaybeUninit::uninit(); 3 * ::core::mem::size_of::<*const u8>()],
);
#[rustfmt::skip]
#[allow(dead_code, clippy::all)]
pub mod wasi {
    pub mod keyvalue {
        /// A keyvalue interface that provides eventually consistent key-value operations.
        ///
        /// Each of these operations acts on a single key-value pair.
        ///
        /// The value in the key-value pair is defined as a `u8` byte array and the intention is that it is
        /// the common denominator for all data types defined by different key-value stores to handle data,
        /// ensuring compatibility between different key-value stores. Note: the clients will be expecting
        /// serialization/deserialization overhead to be handled by the key-value store. The value could be
        /// a serialized object from JSON, HTML or vendor-specific data types like AWS S3 objects.
        ///
        /// Data consistency in a key value store refers to the guarantee that once a write operation
        /// completes, all subsequent read operations will return the value that was written.
        ///
        /// Any implementation of this interface must have enough consistency to guarantee "reading your
        /// writes." In particular, this means that the client should never get a value that is older than
        /// the one it wrote, but it MAY get a newer value if one was written around the same time. These
        /// guarantees only apply to the same client (which will likely be provided by the host or an
        /// external capability of some kind). In this context a "client" is referring to the caller or
        /// guest that is consuming this interface. Once a write request is committed by a specific client,
        /// all subsequent read requests by the same client will reflect that write or any subsequent
        /// writes. Another client running in a different context may or may not immediately see the result
        /// due to the replication lag. As an example of all of this, if a value at a given key is A, and
        /// the client writes B, then immediately reads, it should get B. If something else writes C in
        /// quick succession, then the client may get C. However, a client running in a separate context may
        /// still see A or B
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod store {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            /// The set of errors which may be raised by functions in this package
            #[derive(Clone)]
            pub enum Error {
                /// The host does not recognize the store identifier requested.
                NoSuchStore,
                /// The requesting component does not have access to the specified store
                /// (which may or may not exist).
                AccessDenied,
                /// Some implementation-specific error has occurred (e.g. I/O)
                Other(_rt::String),
            }
            impl ::core::fmt::Debug for Error {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        Error::NoSuchStore => {
                            f.debug_tuple("Error::NoSuchStore").finish()
                        }
                        Error::AccessDenied => {
                            f.debug_tuple("Error::AccessDenied").finish()
                        }
                        Error::Other(e) => {
                            f.debug_tuple("Error::Other").field(e).finish()
                        }
                    }
                }
            }
            impl ::core::fmt::Display for Error {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    write!(f, "{:?}", self)
                }
            }
            impl std::error::Error for Error {}
            /// A response to a `list-keys` operation.
            #[derive(Clone)]
            pub struct KeyResponse {
                /// The list of keys returned by the query.
                pub keys: _rt::Vec<_rt::String>,
                /// The continuation token to use to fetch the next page of keys. If this is `null`, then
                /// there are no more keys to fetch.
                pub cursor: Option<u64>,
            }
            impl ::core::fmt::Debug for KeyResponse {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("KeyResponse")
                        .field("keys", &self.keys)
                        .field("cursor", &self.cursor)
                        .finish()
                }
            }
            /// A bucket is a collection of key-value pairs. Each key-value pair is stored as a entry in the
            /// bucket, and the bucket itself acts as a collection of all these entries.
            ///
            /// It is worth noting that the exact terminology for bucket in key-value stores can very
            /// depending on the specific implementation. For example:
            ///
            /// 1. Amazon DynamoDB calls a collection of key-value pairs a table
            /// 2. Redis has hashes, sets, and sorted sets as different types of collections
            /// 3. Cassandra calls a collection of key-value pairs a column family
            /// 4. MongoDB calls a collection of key-value pairs a collection
            /// 5. Riak calls a collection of key-value pairs a bucket
            /// 6. Memcached calls a collection of key-value pairs a slab
            /// 7. Azure Cosmos DB calls a collection of key-value pairs a container
            ///
            /// In this interface, we use the term `bucket` to refer to a collection of key-value pairs
            #[derive(Debug)]
            #[repr(transparent)]
            pub struct Bucket {
                handle: _rt::Resource<Bucket>,
            }
            impl Bucket {
                #[doc(hidden)]
                pub unsafe fn from_handle(handle: u32) -> Self {
                    Self {
                        handle: unsafe { _rt::Resource::from_handle(handle) },
                    }
                }
                #[doc(hidden)]
                pub fn take_handle(&self) -> u32 {
                    _rt::Resource::take_handle(&self.handle)
                }
                #[doc(hidden)]
                pub fn handle(&self) -> u32 {
                    _rt::Resource::handle(&self.handle)
                }
            }
            unsafe impl _rt::WasmResource for Bucket {
                #[inline]
                unsafe fn drop(_handle: u32) {
                    #[cfg(not(target_arch = "wasm32"))]
                    unreachable!();
                    #[cfg(target_arch = "wasm32")]
                    {
                        #[link(wasm_import_module = "wasi:keyvalue/store@0.2.0-draft")]
                        unsafe extern "C" {
                            #[link_name = "[resource-drop]bucket"]
                            fn drop(_: u32);
                        }
                        unsafe { drop(_handle) };
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Get the bucket with the specified identifier.
            ///
            /// `identifier` must refer to a bucket provided by the host.
            ///
            /// `error::no-such-store` will be raised if the `identifier` is not recognized.
            pub fn open(identifier: &str) -> Result<Bucket, Error> {
                unsafe {
                    #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                    #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 4 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 4
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let vec0 = identifier;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "wasi:keyvalue/store@0.2.0-draft")]
                    unsafe extern "C" {
                        #[link_name = "open"]
                        fn wit_import2(_: *mut u8, _: usize, _: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import2(_: *mut u8, _: usize, _: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import2(ptr0.cast_mut(), len0, ptr1) };
                    let l3 = i32::from(*ptr1.add(0).cast::<u8>());
                    let result10 = match l3 {
                        0 => {
                            let e = {
                                let l4 = *ptr1
                                    .add(::core::mem::size_of::<*const u8>())
                                    .cast::<i32>();
                                unsafe { Bucket::from_handle(l4 as u32) }
                            };
                            Ok(e)
                        }
                        1 => {
                            let e = {
                                let l5 = i32::from(
                                    *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                                );
                                let v9 = match l5 {
                                    0 => Error::NoSuchStore,
                                    1 => Error::AccessDenied,
                                    n => {
                                        debug_assert_eq!(n, 2, "invalid enum discriminant");
                                        let e9 = {
                                            let l6 = *ptr1
                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>();
                                            let l7 = *ptr1
                                                .add(3 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>();
                                            let len8 = l7;
                                            let bytes8 = _rt::Vec::from_raw_parts(
                                                l6.cast(),
                                                len8,
                                                len8,
                                            );
                                            _rt::string_lift(bytes8)
                                        };
                                        Error::Other(e9)
                                    }
                                };
                                v9
                            };
                            Err(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    };
                    result10
                }
            }
            impl Bucket {
                #[allow(unused_unsafe, clippy::all)]
                /// Get the value associated with the specified `key`
                ///
                /// The value is returned as an option. If the key-value pair exists in the
                /// store, it returns `Ok(value)`. If the key does not exist in the
                /// store, it returns `Ok(none)`.
                ///
                /// If any other error occurs, it returns an `Err(error)`.
                pub fn get(&self, key: &str) -> Result<Option<_rt::Vec<u8>>, Error> {
                    unsafe {
                        #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                        #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                        struct RetArea(
                            [::core::mem::MaybeUninit<
                                u8,
                            >; 4 * ::core::mem::size_of::<*const u8>()],
                        );
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 4
                                * ::core::mem::size_of::<*const u8>()],
                        );
                        let vec0 = key;
                        let ptr0 = vec0.as_ptr().cast::<u8>();
                        let len0 = vec0.len();
                        let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:keyvalue/store@0.2.0-draft")]
                        unsafe extern "C" {
                            #[link_name = "[method]bucket.get"]
                            fn wit_import2(_: i32, _: *mut u8, _: usize, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import2(
                            _: i32,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        ) {
                            unreachable!()
                        }
                        unsafe {
                            wit_import2(
                                (self).handle() as i32,
                                ptr0.cast_mut(),
                                len0,
                                ptr1,
                            )
                        };
                        let l3 = i32::from(*ptr1.add(0).cast::<u8>());
                        let result13 = match l3 {
                            0 => {
                                let e = {
                                    let l4 = i32::from(
                                        *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                                    );
                                    match l4 {
                                        0 => None,
                                        1 => {
                                            let e = {
                                                let l5 = *ptr1
                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l6 = *ptr1
                                                    .add(3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len7 = l6;
                                                _rt::Vec::from_raw_parts(l5.cast(), len7, len7)
                                            };
                                            Some(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    }
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l8 = i32::from(
                                        *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                                    );
                                    let v12 = match l8 {
                                        0 => Error::NoSuchStore,
                                        1 => Error::AccessDenied,
                                        n => {
                                            debug_assert_eq!(n, 2, "invalid enum discriminant");
                                            let e12 = {
                                                let l9 = *ptr1
                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l10 = *ptr1
                                                    .add(3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len11 = l10;
                                                let bytes11 = _rt::Vec::from_raw_parts(
                                                    l9.cast(),
                                                    len11,
                                                    len11,
                                                );
                                                _rt::string_lift(bytes11)
                                            };
                                            Error::Other(e12)
                                        }
                                    };
                                    v12
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result13
                    }
                }
            }
            impl Bucket {
                #[allow(unused_unsafe, clippy::all)]
                /// Set the value associated with the key in the store. If the key already
                /// exists in the store, it overwrites the value.
                ///
                /// If the key does not exist in the store, it creates a new key-value pair.
                ///
                /// If any other error occurs, it returns an `Err(error)`.
                pub fn set(&self, key: &str, value: &[u8]) -> Result<(), Error> {
                    unsafe {
                        #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                        #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                        struct RetArea(
                            [::core::mem::MaybeUninit<
                                u8,
                            >; 4 * ::core::mem::size_of::<*const u8>()],
                        );
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 4
                                * ::core::mem::size_of::<*const u8>()],
                        );
                        let vec0 = key;
                        let ptr0 = vec0.as_ptr().cast::<u8>();
                        let len0 = vec0.len();
                        let vec1 = value;
                        let ptr1 = vec1.as_ptr().cast::<u8>();
                        let len1 = vec1.len();
                        let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:keyvalue/store@0.2.0-draft")]
                        unsafe extern "C" {
                            #[link_name = "[method]bucket.set"]
                            fn wit_import3(
                                _: i32,
                                _: *mut u8,
                                _: usize,
                                _: *mut u8,
                                _: usize,
                                _: *mut u8,
                            );
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import3(
                            _: i32,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        ) {
                            unreachable!()
                        }
                        unsafe {
                            wit_import3(
                                (self).handle() as i32,
                                ptr0.cast_mut(),
                                len0,
                                ptr1.cast_mut(),
                                len1,
                                ptr2,
                            )
                        };
                        let l4 = i32::from(*ptr2.add(0).cast::<u8>());
                        let result10 = match l4 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l5 = i32::from(
                                        *ptr2.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                                    );
                                    let v9 = match l5 {
                                        0 => Error::NoSuchStore,
                                        1 => Error::AccessDenied,
                                        n => {
                                            debug_assert_eq!(n, 2, "invalid enum discriminant");
                                            let e9 = {
                                                let l6 = *ptr2
                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l7 = *ptr2
                                                    .add(3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len8 = l7;
                                                let bytes8 = _rt::Vec::from_raw_parts(
                                                    l6.cast(),
                                                    len8,
                                                    len8,
                                                );
                                                _rt::string_lift(bytes8)
                                            };
                                            Error::Other(e9)
                                        }
                                    };
                                    v9
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result10
                    }
                }
            }
            impl Bucket {
                #[allow(unused_unsafe, clippy::all)]
                /// Delete the key-value pair associated with the key in the store.
                ///
                /// If the key does not exist in the store, it does nothing.
                ///
                /// If any other error occurs, it returns an `Err(error)`.
                pub fn delete(&self, key: &str) -> Result<(), Error> {
                    unsafe {
                        #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                        #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                        struct RetArea(
                            [::core::mem::MaybeUninit<
                                u8,
                            >; 4 * ::core::mem::size_of::<*const u8>()],
                        );
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 4
                                * ::core::mem::size_of::<*const u8>()],
                        );
                        let vec0 = key;
                        let ptr0 = vec0.as_ptr().cast::<u8>();
                        let len0 = vec0.len();
                        let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:keyvalue/store@0.2.0-draft")]
                        unsafe extern "C" {
                            #[link_name = "[method]bucket.delete"]
                            fn wit_import2(_: i32, _: *mut u8, _: usize, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import2(
                            _: i32,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        ) {
                            unreachable!()
                        }
                        unsafe {
                            wit_import2(
                                (self).handle() as i32,
                                ptr0.cast_mut(),
                                len0,
                                ptr1,
                            )
                        };
                        let l3 = i32::from(*ptr1.add(0).cast::<u8>());
                        let result9 = match l3 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l4 = i32::from(
                                        *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                                    );
                                    let v8 = match l4 {
                                        0 => Error::NoSuchStore,
                                        1 => Error::AccessDenied,
                                        n => {
                                            debug_assert_eq!(n, 2, "invalid enum discriminant");
                                            let e8 = {
                                                let l5 = *ptr1
                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l6 = *ptr1
                                                    .add(3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len7 = l6;
                                                let bytes7 = _rt::Vec::from_raw_parts(
                                                    l5.cast(),
                                                    len7,
                                                    len7,
                                                );
                                                _rt::string_lift(bytes7)
                                            };
                                            Error::Other(e8)
                                        }
                                    };
                                    v8
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result9
                    }
                }
            }
            impl Bucket {
                #[allow(unused_unsafe, clippy::all)]
                /// Check if the key exists in the store.
                ///
                /// If the key exists in the store, it returns `Ok(true)`. If the key does
                /// not exist in the store, it returns `Ok(false)`.
                ///
                /// If any other error occurs, it returns an `Err(error)`.
                pub fn exists(&self, key: &str) -> Result<bool, Error> {
                    unsafe {
                        #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                        #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                        struct RetArea(
                            [::core::mem::MaybeUninit<
                                u8,
                            >; 4 * ::core::mem::size_of::<*const u8>()],
                        );
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 4
                                * ::core::mem::size_of::<*const u8>()],
                        );
                        let vec0 = key;
                        let ptr0 = vec0.as_ptr().cast::<u8>();
                        let len0 = vec0.len();
                        let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:keyvalue/store@0.2.0-draft")]
                        unsafe extern "C" {
                            #[link_name = "[method]bucket.exists"]
                            fn wit_import2(_: i32, _: *mut u8, _: usize, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import2(
                            _: i32,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        ) {
                            unreachable!()
                        }
                        unsafe {
                            wit_import2(
                                (self).handle() as i32,
                                ptr0.cast_mut(),
                                len0,
                                ptr1,
                            )
                        };
                        let l3 = i32::from(*ptr1.add(0).cast::<u8>());
                        let result10 = match l3 {
                            0 => {
                                let e = {
                                    let l4 = i32::from(
                                        *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                                    );
                                    _rt::bool_lift(l4 as u8)
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l5 = i32::from(
                                        *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                                    );
                                    let v9 = match l5 {
                                        0 => Error::NoSuchStore,
                                        1 => Error::AccessDenied,
                                        n => {
                                            debug_assert_eq!(n, 2, "invalid enum discriminant");
                                            let e9 = {
                                                let l6 = *ptr1
                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l7 = *ptr1
                                                    .add(3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len8 = l7;
                                                let bytes8 = _rt::Vec::from_raw_parts(
                                                    l6.cast(),
                                                    len8,
                                                    len8,
                                                );
                                                _rt::string_lift(bytes8)
                                            };
                                            Error::Other(e9)
                                        }
                                    };
                                    v9
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result10
                    }
                }
            }
            impl Bucket {
                #[allow(unused_unsafe, clippy::all)]
                /// Get all the keys in the store with an optional cursor (for use in pagination). It
                /// returns a list of keys. Please note that for most KeyValue implementations, this is a
                /// can be a very expensive operation and so it should be used judiciously. Implementations
                /// can return any number of keys in a single response, but they should never attempt to
                /// send more data than is reasonable (i.e. on a small edge device, this may only be a few
                /// KB, while on a large machine this could be several MB). Any response should also return
                /// a cursor that can be used to fetch the next page of keys. See the `key-response` record
                /// for more information.
                ///
                /// Note that the keys are not guaranteed to be returned in any particular order.
                ///
                /// If the store is empty, it returns an empty list.
                ///
                /// MAY show an out-of-date list of keys if there are concurrent writes to the store.
                ///
                /// If any error occurs, it returns an `Err(error)`.
                pub fn list_keys(
                    &self,
                    cursor: Option<u64>,
                ) -> Result<KeyResponse, Error> {
                    unsafe {
                        #[repr(align(8))]
                        struct RetArea(
                            [::core::mem::MaybeUninit<
                                u8,
                            >; 24 + 2 * ::core::mem::size_of::<*const u8>()],
                        );
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 24
                                + 2 * ::core::mem::size_of::<*const u8>()],
                        );
                        let (result0_0, result0_1) = match cursor {
                            Some(e) => (1i32, _rt::as_i64(e)),
                            None => (0i32, 0i64),
                        };
                        let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:keyvalue/store@0.2.0-draft")]
                        unsafe extern "C" {
                            #[link_name = "[method]bucket.list-keys"]
                            fn wit_import2(_: i32, _: i32, _: i64, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import2(
                            _: i32,
                            _: i32,
                            _: i64,
                            _: *mut u8,
                        ) {
                            unreachable!()
                        }
                        unsafe {
                            wit_import2(
                                (self).handle() as i32,
                                result0_0,
                                result0_1,
                                ptr1,
                            )
                        };
                        let l3 = i32::from(*ptr1.add(0).cast::<u8>());
                        let result17 = match l3 {
                            0 => {
                                let e = {
                                    let l4 = *ptr1.add(8).cast::<*mut u8>();
                                    let l5 = *ptr1
                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    let base9 = l4;
                                    let len9 = l5;
                                    let mut result9 = _rt::Vec::with_capacity(len9);
                                    for i in 0..len9 {
                                        let base = base9
                                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                        let e9 = {
                                            let l6 = *base.add(0).cast::<*mut u8>();
                                            let l7 = *base
                                                .add(::core::mem::size_of::<*const u8>())
                                                .cast::<usize>();
                                            let len8 = l7;
                                            let bytes8 = _rt::Vec::from_raw_parts(
                                                l6.cast(),
                                                len8,
                                                len8,
                                            );
                                            _rt::string_lift(bytes8)
                                        };
                                        result9.push(e9);
                                    }
                                    _rt::cabi_dealloc(
                                        base9,
                                        len9 * (2 * ::core::mem::size_of::<*const u8>()),
                                        ::core::mem::size_of::<*const u8>(),
                                    );
                                    let l10 = i32::from(
                                        *ptr1
                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>(),
                                    );
                                    KeyResponse {
                                        keys: result9,
                                        cursor: match l10 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l11 = *ptr1
                                                        .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<i64>();
                                                    l11 as u64
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                    }
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l12 = i32::from(*ptr1.add(8).cast::<u8>());
                                    let v16 = match l12 {
                                        0 => Error::NoSuchStore,
                                        1 => Error::AccessDenied,
                                        n => {
                                            debug_assert_eq!(n, 2, "invalid enum discriminant");
                                            let e16 = {
                                                let l13 = *ptr1
                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l14 = *ptr1
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len15 = l14;
                                                let bytes15 = _rt::Vec::from_raw_parts(
                                                    l13.cast(),
                                                    len15,
                                                    len15,
                                                );
                                                _rt::string_lift(bytes15)
                                            };
                                            Error::Other(e16)
                                        }
                                    };
                                    v16
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result17
                    }
                }
            }
        }
        /// A keyvalue interface that provides batch operations.
        ///
        /// A batch operation is an operation that operates on multiple keys at once.
        ///
        /// Batch operations are useful for reducing network round-trip time. For example, if you want to
        /// get the values associated with 100 keys, you can either do 100 get operations or you can do 1
        /// batch get operation. The batch operation is faster because it only needs to make 1 network call
        /// instead of 100.
        ///
        /// A batch operation does not guarantee atomicity, meaning that if the batch operation fails, some
        /// of the keys may have been modified and some may not.
        ///
        /// This interface does has the same consistency guarantees as the `store` interface, meaning that
        /// you should be able to "read your writes."
        ///
        /// Please note that this interface is bare functions that take a reference to a bucket. This is to
        /// get around the current lack of a way to "extend" a resource with additional methods inside of
        /// wit. Future version of the interface will instead extend these methods on the base `bucket`
        /// resource.
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod batch {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            pub type Bucket = super::super::super::wasi::keyvalue::store::Bucket;
            pub type Error = super::super::super::wasi::keyvalue::store::Error;
            #[allow(unused_unsafe, clippy::all)]
            /// Get the key-value pairs associated with the keys in the store. It returns a list of
            /// key-value pairs.
            ///
            /// If any of the keys do not exist in the store, it returns a `none` value for that pair in the
            /// list.
            ///
            /// MAY show an out-of-date value if there are concurrent writes to the store.
            ///
            /// If any other error occurs, it returns an `Err(error)`.
            pub fn get_many(
                bucket: &Bucket,
                keys: &[_rt::String],
            ) -> Result<_rt::Vec<Option<(_rt::String, _rt::Vec<u8>)>>, Error> {
                unsafe {
                    #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                    #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 4 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 4
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let vec1 = keys;
                    let len1 = vec1.len();
                    let layout1 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec1.len() * (2 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let result1 = if layout1.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout1).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout1);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec1.into_iter().enumerate() {
                        let base = result1
                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                        {
                            let vec0 = e;
                            let ptr0 = vec0.as_ptr().cast::<u8>();
                            let len0 = vec0.len();
                            *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len0;
                            *base.add(0).cast::<*mut u8>() = ptr0.cast_mut();
                        }
                    }
                    let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "wasi:keyvalue/batch@0.2.0-draft")]
                    unsafe extern "C" {
                        #[link_name = "get-many"]
                        fn wit_import3(_: i32, _: *mut u8, _: usize, _: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import3(
                        _: i32,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                    ) {
                        unreachable!()
                    }
                    unsafe {
                        wit_import3((bucket).handle() as i32, result1, len1, ptr2)
                    };
                    let l4 = i32::from(*ptr2.add(0).cast::<u8>());
                    let result20 = match l4 {
                        0 => {
                            let e = {
                                let l5 = *ptr2
                                    .add(::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>();
                                let l6 = *ptr2
                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>();
                                let base14 = l5;
                                let len14 = l6;
                                let mut result14 = _rt::Vec::with_capacity(len14);
                                for i in 0..len14 {
                                    let base = base14
                                        .add(i * (5 * ::core::mem::size_of::<*const u8>()));
                                    let e14 = {
                                        let l7 = i32::from(*base.add(0).cast::<u8>());
                                        match l7 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l8 = *base
                                                        .add(::core::mem::size_of::<*const u8>())
                                                        .cast::<*mut u8>();
                                                    let l9 = *base
                                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<usize>();
                                                    let len10 = l9;
                                                    let bytes10 = _rt::Vec::from_raw_parts(
                                                        l8.cast(),
                                                        len10,
                                                        len10,
                                                    );
                                                    let l11 = *base
                                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<*mut u8>();
                                                    let l12 = *base
                                                        .add(4 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<usize>();
                                                    let len13 = l12;
                                                    (
                                                        _rt::string_lift(bytes10),
                                                        _rt::Vec::from_raw_parts(l11.cast(), len13, len13),
                                                    )
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        }
                                    };
                                    result14.push(e14);
                                }
                                _rt::cabi_dealloc(
                                    base14,
                                    len14 * (5 * ::core::mem::size_of::<*const u8>()),
                                    ::core::mem::size_of::<*const u8>(),
                                );
                                result14
                            };
                            Ok(e)
                        }
                        1 => {
                            let e = {
                                let l15 = i32::from(
                                    *ptr2.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                                );
                                use super::super::super::wasi::keyvalue::store::Error as V19;
                                let v19 = match l15 {
                                    0 => V19::NoSuchStore,
                                    1 => V19::AccessDenied,
                                    n => {
                                        debug_assert_eq!(n, 2, "invalid enum discriminant");
                                        let e19 = {
                                            let l16 = *ptr2
                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>();
                                            let l17 = *ptr2
                                                .add(3 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>();
                                            let len18 = l17;
                                            let bytes18 = _rt::Vec::from_raw_parts(
                                                l16.cast(),
                                                len18,
                                                len18,
                                            );
                                            _rt::string_lift(bytes18)
                                        };
                                        V19::Other(e19)
                                    }
                                };
                                v19
                            };
                            Err(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    };
                    if layout1.size() != 0 {
                        _rt::alloc::dealloc(result1.cast(), layout1);
                    }
                    result20
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Set the values associated with the keys in the store. If the key already exists in the
            /// store, it overwrites the value.
            ///
            /// Note that the key-value pairs are not guaranteed to be set in the order they are provided.
            ///
            /// If any of the keys do not exist in the store, it creates a new key-value pair.
            ///
            /// If any other error occurs, it returns an `Err(error)`. When an error occurs, it does not
            /// rollback the key-value pairs that were already set. Thus, this batch operation does not
            /// guarantee atomicity, implying that some key-value pairs could be set while others might
            /// fail.
            ///
            /// Other concurrent operations may also be able to see the partial results.
            pub fn set_many(
                bucket: &Bucket,
                key_values: &[(_rt::String, _rt::Vec<u8>)],
            ) -> Result<(), Error> {
                unsafe {
                    #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                    #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 4 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 4
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let vec3 = key_values;
                    let len3 = vec3.len();
                    let layout3 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec3.len() * (4 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let result3 = if layout3.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout3).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout3);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec3.into_iter().enumerate() {
                        let base = result3
                            .add(i * (4 * ::core::mem::size_of::<*const u8>()));
                        {
                            let (t0_0, t0_1) = e;
                            let vec1 = t0_0;
                            let ptr1 = vec1.as_ptr().cast::<u8>();
                            let len1 = vec1.len();
                            *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len1;
                            *base.add(0).cast::<*mut u8>() = ptr1.cast_mut();
                            let vec2 = t0_1;
                            let ptr2 = vec2.as_ptr().cast::<u8>();
                            let len2 = vec2.len();
                            *base
                                .add(3 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len2;
                            *base
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr2.cast_mut();
                        }
                    }
                    let ptr4 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "wasi:keyvalue/batch@0.2.0-draft")]
                    unsafe extern "C" {
                        #[link_name = "set-many"]
                        fn wit_import5(_: i32, _: *mut u8, _: usize, _: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import5(
                        _: i32,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                    ) {
                        unreachable!()
                    }
                    unsafe {
                        wit_import5((bucket).handle() as i32, result3, len3, ptr4)
                    };
                    let l6 = i32::from(*ptr4.add(0).cast::<u8>());
                    let result12 = match l6 {
                        0 => {
                            let e = ();
                            Ok(e)
                        }
                        1 => {
                            let e = {
                                let l7 = i32::from(
                                    *ptr4.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                                );
                                use super::super::super::wasi::keyvalue::store::Error as V11;
                                let v11 = match l7 {
                                    0 => V11::NoSuchStore,
                                    1 => V11::AccessDenied,
                                    n => {
                                        debug_assert_eq!(n, 2, "invalid enum discriminant");
                                        let e11 = {
                                            let l8 = *ptr4
                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>();
                                            let l9 = *ptr4
                                                .add(3 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>();
                                            let len10 = l9;
                                            let bytes10 = _rt::Vec::from_raw_parts(
                                                l8.cast(),
                                                len10,
                                                len10,
                                            );
                                            _rt::string_lift(bytes10)
                                        };
                                        V11::Other(e11)
                                    }
                                };
                                v11
                            };
                            Err(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    };
                    if layout3.size() != 0 {
                        _rt::alloc::dealloc(result3.cast(), layout3);
                    }
                    result12
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Delete the key-value pairs associated with the keys in the store.
            ///
            /// Note that the key-value pairs are not guaranteed to be deleted in the order they are
            /// provided.
            ///
            /// If any of the keys do not exist in the store, it skips the key.
            ///
            /// If any other error occurs, it returns an `Err(error)`. When an error occurs, it does not
            /// rollback the key-value pairs that were already deleted. Thus, this batch operation does not
            /// guarantee atomicity, implying that some key-value pairs could be deleted while others might
            /// fail.
            ///
            /// Other concurrent operations may also be able to see the partial results.
            pub fn delete_many(
                bucket: &Bucket,
                keys: &[_rt::String],
            ) -> Result<(), Error> {
                unsafe {
                    #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                    #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 4 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 4
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let vec1 = keys;
                    let len1 = vec1.len();
                    let layout1 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec1.len() * (2 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let result1 = if layout1.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout1).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout1);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec1.into_iter().enumerate() {
                        let base = result1
                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                        {
                            let vec0 = e;
                            let ptr0 = vec0.as_ptr().cast::<u8>();
                            let len0 = vec0.len();
                            *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len0;
                            *base.add(0).cast::<*mut u8>() = ptr0.cast_mut();
                        }
                    }
                    let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "wasi:keyvalue/batch@0.2.0-draft")]
                    unsafe extern "C" {
                        #[link_name = "delete-many"]
                        fn wit_import3(_: i32, _: *mut u8, _: usize, _: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import3(
                        _: i32,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                    ) {
                        unreachable!()
                    }
                    unsafe {
                        wit_import3((bucket).handle() as i32, result1, len1, ptr2)
                    };
                    let l4 = i32::from(*ptr2.add(0).cast::<u8>());
                    let result10 = match l4 {
                        0 => {
                            let e = ();
                            Ok(e)
                        }
                        1 => {
                            let e = {
                                let l5 = i32::from(
                                    *ptr2.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                                );
                                use super::super::super::wasi::keyvalue::store::Error as V9;
                                let v9 = match l5 {
                                    0 => V9::NoSuchStore,
                                    1 => V9::AccessDenied,
                                    n => {
                                        debug_assert_eq!(n, 2, "invalid enum discriminant");
                                        let e9 = {
                                            let l6 = *ptr2
                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>();
                                            let l7 = *ptr2
                                                .add(3 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>();
                                            let len8 = l7;
                                            let bytes8 = _rt::Vec::from_raw_parts(
                                                l6.cast(),
                                                len8,
                                                len8,
                                            );
                                            _rt::string_lift(bytes8)
                                        };
                                        V9::Other(e9)
                                    }
                                };
                                v9
                            };
                            Err(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    };
                    if layout1.size() != 0 {
                        _rt::alloc::dealloc(result1.cast(), layout1);
                    }
                    result10
                }
            }
        }
        /// A keyvalue interface that provides atomic operations.
        ///
        /// Atomic operations are single, indivisible operations. When a fault causes an atomic operation to
        /// fail, it will appear to the invoker of the atomic operation that the action either completed
        /// successfully or did nothing at all.
        ///
        /// Please note that this interface is bare functions that take a reference to a bucket. This is to
        /// get around the current lack of a way to "extend" a resource with additional methods inside of
        /// wit. Future version of the interface will instead extend these methods on the base `bucket`
        /// resource.
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod atomics {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            pub type Bucket = super::super::super::wasi::keyvalue::store::Bucket;
            pub type Error = super::super::super::wasi::keyvalue::store::Error;
            #[allow(unused_unsafe, clippy::all)]
            /// Atomically increment the value associated with the key in the store by the given delta. It
            /// returns the new value.
            ///
            /// If the key does not exist in the store, it creates a new key-value pair with the value set
            /// to the given delta.
            ///
            /// If any other error occurs, it returns an `Err(error)`.
            pub fn increment(
                bucket: &Bucket,
                key: &str,
                delta: u64,
            ) -> Result<u64, Error> {
                unsafe {
                    #[repr(align(8))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 16 + 2 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 16
                            + 2 * ::core::mem::size_of::<*const u8>()],
                    );
                    let vec0 = key;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "wasi:keyvalue/atomics@0.2.0-draft")]
                    unsafe extern "C" {
                        #[link_name = "increment"]
                        fn wit_import2(_: i32, _: *mut u8, _: usize, _: i64, _: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import2(
                        _: i32,
                        _: *mut u8,
                        _: usize,
                        _: i64,
                        _: *mut u8,
                    ) {
                        unreachable!()
                    }
                    unsafe {
                        wit_import2(
                            (bucket).handle() as i32,
                            ptr0.cast_mut(),
                            len0,
                            _rt::as_i64(&delta),
                            ptr1,
                        )
                    };
                    let l3 = i32::from(*ptr1.add(0).cast::<u8>());
                    let result10 = match l3 {
                        0 => {
                            let e = {
                                let l4 = *ptr1.add(8).cast::<i64>();
                                l4 as u64
                            };
                            Ok(e)
                        }
                        1 => {
                            let e = {
                                let l5 = i32::from(*ptr1.add(8).cast::<u8>());
                                use super::super::super::wasi::keyvalue::store::Error as V9;
                                let v9 = match l5 {
                                    0 => V9::NoSuchStore,
                                    1 => V9::AccessDenied,
                                    n => {
                                        debug_assert_eq!(n, 2, "invalid enum discriminant");
                                        let e9 = {
                                            let l6 = *ptr1
                                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>();
                                            let l7 = *ptr1
                                                .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>();
                                            let len8 = l7;
                                            let bytes8 = _rt::Vec::from_raw_parts(
                                                l6.cast(),
                                                len8,
                                                len8,
                                            );
                                            _rt::string_lift(bytes8)
                                        };
                                        V9::Other(e9)
                                    }
                                };
                                v9
                            };
                            Err(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    };
                    result10
                }
            }
        }
    }
}
#[rustfmt::skip]
mod _rt {
    #![allow(dead_code, clippy::all)]
    pub use alloc_crate::string::String;
    pub use alloc_crate::vec::Vec;
    use core::fmt;
    use core::marker;
    use core::sync::atomic::{AtomicU32, Ordering::Relaxed};
    /// A type which represents a component model resource, either imported or
    /// exported into this component.
    ///
    /// This is a low-level wrapper which handles the lifetime of the resource
    /// (namely this has a destructor). The `T` provided defines the component model
    /// intrinsics that this wrapper uses.
    ///
    /// One of the chief purposes of this type is to provide `Deref` implementations
    /// to access the underlying data when it is owned.
    ///
    /// This type is primarily used in generated code for exported and imported
    /// resources.
    #[repr(transparent)]
    pub struct Resource<T: WasmResource> {
        handle: AtomicU32,
        _marker: marker::PhantomData<T>,
    }
    /// A trait which all wasm resources implement, namely providing the ability to
    /// drop a resource.
    ///
    /// This generally is implemented by generated code, not user-facing code.
    #[allow(clippy::missing_safety_doc)]
    pub unsafe trait WasmResource {
        /// Invokes the `[resource-drop]...` intrinsic.
        unsafe fn drop(handle: u32);
    }
    impl<T: WasmResource> Resource<T> {
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
            debug_assert!(handle != u32::MAX);
            Self {
                handle: AtomicU32::new(handle),
                _marker: marker::PhantomData,
            }
        }
        /// Takes ownership of the handle owned by `resource`.
        ///
        /// Note that this ideally would be `into_handle` taking `Resource<T>` by
        /// ownership. The code generator does not enable that in all situations,
        /// unfortunately, so this is provided instead.
        ///
        /// Also note that `take_handle` is in theory only ever called on values
        /// owned by a generated function. For example a generated function might
        /// take `Resource<T>` as an argument but then call `take_handle` on a
        /// reference to that argument. In that sense the dynamic nature of
        /// `take_handle` should only be exposed internally to generated code, not
        /// to user code.
        #[doc(hidden)]
        pub fn take_handle(resource: &Resource<T>) -> u32 {
            resource.handle.swap(u32::MAX, Relaxed)
        }
        #[doc(hidden)]
        pub fn handle(resource: &Resource<T>) -> u32 {
            resource.handle.load(Relaxed)
        }
    }
    impl<T: WasmResource> fmt::Debug for Resource<T> {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            f.debug_struct("Resource").field("handle", &self.handle).finish()
        }
    }
    impl<T: WasmResource> Drop for Resource<T> {
        fn drop(&mut self) {
            unsafe {
                match self.handle.load(Relaxed) {
                    u32::MAX => {}
                    other => T::drop(other),
                }
            }
        }
    }
    pub unsafe fn string_lift(bytes: Vec<u8>) -> String {
        if cfg!(debug_assertions) {
            String::from_utf8(bytes).unwrap()
        } else {
            String::from_utf8_unchecked(bytes)
        }
    }
    pub unsafe fn invalid_enum_discriminant<T>() -> T {
        if cfg!(debug_assertions) {
            panic!("invalid enum discriminant")
        } else {
            unsafe { core::hint::unreachable_unchecked() }
        }
    }
    pub unsafe fn bool_lift(val: u8) -> bool {
        if cfg!(debug_assertions) {
            match val {
                0 => false,
                1 => true,
                _ => panic!("invalid bool discriminant"),
            }
        } else {
            val != 0
        }
    }
    pub fn as_i64<T: AsI64>(t: T) -> i64 {
        t.as_i64()
    }
    pub trait AsI64 {
        fn as_i64(self) -> i64;
    }
    impl<'a, T: Copy + AsI64> AsI64 for &'a T {
        fn as_i64(self) -> i64 {
            (*self).as_i64()
        }
    }
    impl AsI64 for i64 {
        #[inline]
        fn as_i64(self) -> i64 {
            self as i64
        }
    }
    impl AsI64 for u64 {
        #[inline]
        fn as_i64(self) -> i64 {
            self as i64
        }
    }
    pub unsafe fn cabi_dealloc(ptr: *mut u8, size: usize, align: usize) {
        if size == 0 {
            return;
        }
        let layout = alloc::Layout::from_size_align_unchecked(size, align);
        alloc::dealloc(ptr, layout);
    }
    pub use alloc_crate::alloc;
    #[cfg(target_arch = "wasm32")]
    pub fn run_ctors_once() {
        wit_bindgen_rt::run_ctors_once();
    }
    extern crate alloc as alloc_crate;
}
/// Generates `#[unsafe(no_mangle)]` functions to export the specified type as
/// the root implementation of all generated traits.
///
/// For more information see the documentation of `wit_bindgen::generate!`.
///
/// ```rust
/// # macro_rules! export{ ($($t:tt)*) => (); }
/// # trait Guest {}
/// struct MyType;
///
/// impl Guest for MyType {
///     // ...
/// }
///
/// export!(MyType);
/// ```
#[allow(unused_macros)]
#[doc(hidden)]
macro_rules! __export_client_impl {
    ($ty:ident) => {
        self::export!($ty with_types_in self);
    };
    ($ty:ident with_types_in $($path_to_types_root:tt)*) => {
        $($path_to_types_root)*:: __export_world_client_cabi!($ty with_types_in
        $($path_to_types_root)*);
    };
}
#[doc(inline)]
pub(crate) use __export_client_impl as export;
#[cfg(target_arch = "wasm32")]
#[unsafe(
    link_section = "component-type:wit-bindgen:0.41.0:snt:kv-test@0.1.0:client:encoded world"
)]
#[doc(hidden)]
#[allow(clippy::octal_escapes)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 973] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\xd0\x06\x01A\x02\x01\
A\x0b\x01B\x1c\x01q\x03\x0dno-such-store\0\0\x0daccess-denied\0\0\x05other\x01s\0\
\x04\0\x05error\x03\0\0\x01ps\x01kw\x01r\x02\x04keys\x02\x06cursor\x03\x04\0\x0c\
key-response\x03\0\x04\x04\0\x06bucket\x03\x01\x01h\x06\x01p}\x01k\x08\x01j\x01\x09\
\x01\x01\x01@\x02\x04self\x07\x03keys\0\x0a\x04\0\x12[method]bucket.get\x01\x0b\x01\
j\0\x01\x01\x01@\x03\x04self\x07\x03keys\x05value\x08\0\x0c\x04\0\x12[method]buc\
ket.set\x01\x0d\x01@\x02\x04self\x07\x03keys\0\x0c\x04\0\x15[method]bucket.delet\
e\x01\x0e\x01j\x01\x7f\x01\x01\x01@\x02\x04self\x07\x03keys\0\x0f\x04\0\x15[meth\
od]bucket.exists\x01\x10\x01j\x01\x05\x01\x01\x01@\x02\x04self\x07\x06cursor\x03\
\0\x11\x04\0\x18[method]bucket.list-keys\x01\x12\x01i\x06\x01j\x01\x13\x01\x01\x01\
@\x01\x0aidentifiers\0\x14\x04\0\x04open\x01\x15\x03\0\x1fwasi:keyvalue/store@0.\
2.0-draft\x05\0\x02\x03\0\0\x06bucket\x02\x03\0\0\x05error\x01B\x13\x02\x03\x02\x01\
\x01\x04\0\x06bucket\x03\0\0\x02\x03\x02\x01\x02\x04\0\x05error\x03\0\x02\x01h\x01\
\x01ps\x01p}\x01o\x02s\x06\x01k\x07\x01p\x08\x01j\x01\x09\x01\x03\x01@\x02\x06bu\
cket\x04\x04keys\x05\0\x0a\x04\0\x08get-many\x01\x0b\x01p\x07\x01j\0\x01\x03\x01\
@\x02\x06bucket\x04\x0akey-values\x0c\0\x0d\x04\0\x08set-many\x01\x0e\x01@\x02\x06\
bucket\x04\x04keys\x05\0\x0d\x04\0\x0bdelete-many\x01\x0f\x03\0\x1fwasi:keyvalue\
/batch@0.2.0-draft\x05\x03\x01B\x08\x02\x03\x02\x01\x01\x04\0\x06bucket\x03\0\0\x02\
\x03\x02\x01\x02\x04\0\x05error\x03\0\x02\x01h\x01\x01j\x01w\x01\x03\x01@\x03\x06\
bucket\x04\x03keys\x05deltaw\0\x05\x04\0\x09increment\x01\x06\x03\0!wasi:keyvalu\
e/atomics@0.2.0-draft\x05\x04\x01j\0\x01s\x01@\0\0\x05\x04\0\x0erun-kv-example\x01\
\x06\x04\0\x18snt:kv-test/client@0.1.0\x04\0\x0b\x0c\x01\0\x06client\x03\0\0\0G\x09\
producers\x01\x0cprocessed-by\x02\x0dwit-component\x070.227.1\x10wit-bindgen-rus\
t\x060.41.0";
#[inline(never)]
#[doc(hidden)]
pub fn __link_custom_section_describing_imports() {
    wit_bindgen_rt::maybe_link_cabi_realloc();
}
