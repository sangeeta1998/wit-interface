use anyhow::{anyhow, bail, Context, Result};
use std::collections::HashMap;
use std::sync::{Arc, Mutex};
use wasmtime::component::*;
use wasmtime::{Config, Engine, Store};

// Generate bindings for the WIT world.
// The path is relative to the host-app's Cargo.toml
wasmtime::component::bindgen!({
    world: "offload-client",
    path: "../wit", // Path to the directory containing host-offload.wit
    async: false, // Set to true if you use async functions in WIT
});

// Renaming for clarity, these types come from the bindgen macro above.
// These are the types defined in your WIT file.
use wasi_custom::host_offload::host_allocator::{
    Handle, HostAllocator, HostError, MatrixDimensions,
};


// Host state to manage allocated buffers and their metadata
#[derive(Default)]
struct MyHostState {
    buffers: HashMap<Handle, Vec<u8>>,
    matrix_dims: HashMap<Handle, (u32, u32)>, // Store rows, cols for matrix handles
    next_handle: Handle,
}

impl MyHostState {
    fn new_handle(&mut self) -> Handle {
        let handle = self.next_handle;
        self.next_handle += 1;
        // Basic overflow check, real app might need robust handle recycling
        if self.next_handle == 0 { panic!("Handle overflow!");}
        handle
    }
}

// Implement the `HostAllocator` trait (which was generated by `bindgen!`)
// This is what the Wasm module will call into.
impl HostAllocator for Arc<Mutex<MyHostState>> {
    fn allocate_buffer(&mut self, size: u64) -> Result<Handle, HostError> {
        println!("[Host] Allocating buffer of size {}", size);
        if size == 0 {
            eprintln!("[Host] Error: Cannot allocate buffer of size 0");
            return Err(HostError::Other("Cannot allocate zero-size buffer".to_string()));
        }
        if size > 1_000_000_000 { // Arbitrary limit
            eprintln!("[Host] Error: Requested size too large");
            return Err(HostError::AllocationFailed);
        }

        let mut state = self.lock().unwrap();
        let handle = state.new_handle();
        state.buffers.insert(handle, vec![0u8; size as usize]);
        println!("[Host] Allocated buffer with handle {}", handle);
        Ok(handle)
    }

    fn free_buffer(&mut self, h: Handle) -> Result<(), HostError> {
        println!("[Host] Freeing buffer with handle {}", h);
        let mut state = self.lock().unwrap();
        if state.buffers.remove(&h).is_some() {
            state.matrix_dims.remove(&h); // Also remove associated dimensions
            println!("[Host] Freed buffer {}", h);
            Ok(())
        } else {
            eprintln!("[Host] Error: Invalid handle {} for free", h);
            Err(HostError::InvalidHandle)
        }
    }

    fn write_to_host(
        &mut self,
        guest_bytes: Vec<u8>, // WIT `list<u8>` becomes `Vec<u8>`
        target_handle: Handle,
        target_offset: u64,
    ) -> Result<(), HostError> {
        println!(
            "[Host] Writing {} bytes to handle {} at offset {}",
            guest_bytes.len(), target_handle, target_offset
        );
        let mut state = self.lock().unwrap();
        match state.buffers.get_mut(&target_handle) {
            Some(buffer) => {
                let offset = target_offset as usize;
                let end = offset + guest_bytes.len();
                if end > buffer.len() {
                    eprintln!("[Host] Error: Write out of bounds for handle {}", target_handle);
                    return Err(HostError::CopyOutOfBounds);
                }
                buffer[offset..end].copy_from_slice(&guest_bytes);
                println!("[Host] Successfully wrote to handle {}", target_handle);

                // Infer dimensions if this is a matrix write (example logic)
                // This is a simplification. A real app needs a better way to associate dims.
                // E.g., if we assume all writes to a new matrix buffer are full writes:
                // Let's say we expect f32 matrices. Size of f32 is 4 bytes.
                const ELEMENT_SIZE: usize = 4;
                if guest_bytes.len() % ELEMENT_SIZE == 0 && guest_bytes.len() > 0 {
                    // Example: if it's a square matrix, or we have a convention
                    let total_elements = guest_bytes.len() / ELEMENT_SIZE;
                    // This is a HUGE simplification. How to get rows/cols?
                    // For now, let's assume if it's written, guest has some idea.
                    // Or, the guest *must* call an `allocate_matrix` function.
                    // For this example, we'll require guest to use `get_matrix_dimensions`
                    // or that `allocate_buffer` + `write_to_host` for a matrix sets it up.
                    // Let's assume for matrix_multiply, dimensions are specified or known.
                }

                Ok(())
            }
            None => {
                eprintln!("[Host] Error: Invalid target handle {} for write", target_handle);
                Err(HostError::InvalidHandle)
            }
        }
    }

    fn read_from_host(
        &mut self,
        source_handle: Handle,
        source_offset: u64,
        len: u64,
    ) -> Result<Vec<u8>, HostError> {
        println!(
            "[Host] Reading {} bytes from handle {} at offset {}",
            len, source_handle, source_offset
        );
        let state = self.lock().unwrap();
        match state.buffers.get(&source_handle) {
            Some(buffer) => {
                let offset = source_offset as usize;
                let read_len = len as usize;
                if offset + read_len > buffer.len() {
                    eprintln!("[Host] Error: Read out of bounds for handle {}", source_handle);
                    return Err(HostError::CopyOutOfBounds);
                }
                let data_slice = buffer[offset..offset + read_len].to_vec();
                println!("[Host] Successfully read {} bytes from handle {}", data_slice.len(), source_handle);
                Ok(data_slice)
            }
            None => {
                eprintln!("[Host] Error: Invalid source handle {} for read", source_handle);
                Err(HostError::InvalidHandle)
            }
        }
    }

    fn matrix_multiply_f32(
        &mut self,
        handle_a: Handle,
        handle_b: Handle,
    ) -> Result<Handle, HostError> {
        println!("[Host] Matrix multiply f32 for A:{} and B:{}", handle_a, handle_b);
        let mut state = self.lock().unwrap();

        // --- Retrieve Matrix A ---
        let (rows_a, cols_a) = *state.matrix_dims.get(&handle_a)
            .ok_or_else(|| {
                eprintln!("[Host] Error: Dimensions not found for matrix A (handle {})", handle_a);
                HostError::InvalidHandle
            })?;
        let buffer_a_bytes = state.buffers.get(&handle_a)
            .ok_or(HostError::InvalidHandle)?;
        let matrix_a = nalgebra::DMatrix::<f32>::from_row_slice(
            rows_a as usize,
            cols_a as usize,
            bytes_to_f32_slice(buffer_a_bytes)
                .ok_or_else(|| HostError::Other("Failed to cast buffer A to f32".to_string()))?,
        );
        println!("[Host] Matrix A ({}x{}) loaded", rows_a, cols_a);

        // --- Retrieve Matrix B ---
        let (rows_b, cols_b) = *state.matrix_dims.get(&handle_b)
            .ok_or_else(|| {
                eprintln!("[Host] Error: Dimensions not found for matrix B (handle {})", handle_b);
                HostError::InvalidHandle
            })?;
        let buffer_b_bytes = state.buffers.get(&handle_b)
            .ok_or(HostError::InvalidHandle)?;
        let matrix_b = nalgebra::DMatrix::<f32>::from_row_slice(
            rows_b as usize,
            cols_b as usize,
            bytes_to_f32_slice(buffer_b_bytes)
                .ok_or_else(|| HostError::Other("Failed to cast buffer B to f32".to_string()))?,
        );
        println!("[Host] Matrix B ({}x{}) loaded", rows_b, cols_b);


        // --- Validate Dimensions ---
        if cols_a != rows_b {
            eprintln!("[Host] Error: Matrix dimension mismatch (A: {}x{}, B: {}x{})", rows_a, cols_a, rows_b, cols_b);
            return Err(HostError::DimensionMismatch);
        }

        // --- Perform Multiplication ---
        let matrix_c = matrix_a * matrix_b;
        println!("[Host] Multiplication C = A x B successful. C is {}x{}", matrix_c.nrows(), matrix_c.ncols());

        // --- Store Result C ---
        let handle_c = state.new_handle();
        let c_bytes = f32_slice_to_bytes(matrix_c.as_slice());
        state.buffers.insert(handle_c, c_bytes);
        state.matrix_dims.insert(handle_c, (matrix_c.nrows() as u32, matrix_c.ncols() as u32));
        println!("[Host] Stored result matrix C with handle {}", handle_c);

        Ok(handle_c)
    }

    fn get_matrix_dimensions(&mut self, h: Handle) -> Result<MatrixDimensions, HostError> {
        println!("[Host] Getting dimensions for handle {}", h);
        let state = self.lock().unwrap();
        match state.matrix_dims.get(&h) {
            Some(&(rows, cols)) => {
                println!("[Host] Dimensions for handle {}: {}x{}", h, rows, cols);
                Ok(MatrixDimensions { rows, cols })
            },
            None => {
                eprintln!("[Host] Error: No dimensions found for handle {}", h);
                Err(HostError::InvalidHandle)
            }
        }
    }

    // This function is used by the bindgen macro to add this resource to the Linker
    fn add_to_linker<T: Send>(linker: &mut Linker<T>, get_cx: impl Fn(&mut T) -> &mut Arc<Mutex<MyHostState>> + Send + Sync + Copy + 'static) -> Result<()> {
        wasi_custom::host_offload::host_allocator::add_to_linker(linker, get_cx)
    }
}

// Helper to convert &[u8] to &[f32]
fn bytes_to_f32_slice(bytes: &[u8]) -> Option<&[f32]> {
    if bytes.len() % std::mem::size_of::<f32>() != 0 {
        return None;
    }
    // Safety: We've checked alignment and size.
    // This is safe if the bytes indeed represent f32 values.
    // A more robust solution would handle potential unaligned reads
    // or use a safer transmutation library. For this example, we assume alignment.
    unsafe {
        Some(std::slice::from_raw_parts(
            bytes.as_ptr() as *const f32,
            bytes.len() / std::mem::size_of::<f32>(),
        ))
    }
}

// Helper to convert &[f32] to Vec<u8>
fn f32_slice_to_bytes(floats: &[f32]) -> Vec<u8> {
    let byte_len = floats.len() * std::mem::size_of::<f32>();
    let mut bytes = Vec::with_capacity(byte_len);
    // Safety: We are converting a slice of f32s to bytes.
    // This is generally safe.
    unsafe {
        bytes.set_len(byte_len); // Important: set_len BEFORE writing
        std::ptr::copy_nonoverlapping(
            floats.as_ptr() as *const u8,
            bytes.as_mut_ptr(),
            byte_len,
        );
    }
    bytes
}


fn main() -> Result<()> {
    let engine = Engine::new(Config::new().wasm_component_model(true))?;
    let mut linker = Linker::new(&engine);

    // Create the host state, wrapped for shared access
    let host_state = Arc::new(Mutex::new(MyHostState::default()));

    // Add the host implementation to the linker
    // The closure `|data: &mut Arc<Mutex<MyHostState>>| data` tells the linker how to get our host state.
    HostAllocator::add_to_linker(&mut linker, |data: &mut Arc<Mutex<MyHostState>>| data)?;


    // If your WIT also includes WASI preview1, link it:
    // wasmtime_wasi::add_to_linker(&mut linker, |s: &mut MyHostState| &mut s.wasi_ctx)?;
    // For this specific example, we are not using wasi_snapshot_preview1 directly.

    let mut store = Store::new(&engine, host_state.clone()); // Pass the host_state to the store

    // Load the Wasm component (replace with your actual path)
    let component_path = "../wasm-module/target/wasm32-unknown-unknown/release/wasm_module.wasm";
    // If you build with `cargo component build --target wasm32-wasi`
    // let component_path = "../wasm-module/target/wasm32-wasi/release/wasm_module.wasm";
    println!("[Host] Loading Wasm component from: {}", component_path);

    let component = Component::from_file(&engine, component_path)
        .context("Failed to load Wasm component")?;

    // Instantiate the component. This links imports.
    // The `OffloadClient` struct is generated by `bindgen!`.
    let (instance, _) = OffloadClient::instantiate(&mut store, &component, &linker)?;
    println!("[Host] Wasm component instantiated.");

    // Call the exported function from the Wasm module
    println!("[Host] Calling 'run-matrix-example' in Wasm...");
    match instance.call_run_matrix_example(&mut store) {
        Ok(Ok(_)) => println!("[Host] 'run-matrix-example' executed successfully."),
        Ok(Err(e)) => eprintln!("[Host] 'run-matrix-example' returned an error: {}", e),
        Err(e) => eprintln!("[Host] Trap during 'run-matrix-example': {}", e),
    }

    Ok(())
}
