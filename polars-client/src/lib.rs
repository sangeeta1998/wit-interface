#[allow(warnings)]
mod bindings;

use bindings::wasi::dataframe::dataframe_analysis::{
    aggregate, filter, from_rows, to_json, Aggregation, ColumnFilter, Comparator, Scalar,
};
use bindings::Guest;

// Define the component that implements the Guest trait.
struct Component;

// Implement the `Guest` trait for our world (generated by wit-bindgen).
// The trait name is `crate::Client` (matching the world name).
impl Guest for Component {
    fn run_dataframe_example() -> Result<(), String> {
        println!("=== WebAssembly DataFrame Test ===");

        // Test 1: Basic dataframe creation and JSON conversion
        println!("Test 1: Creating dataframe from rows...");

        let columns = vec!["city".to_string(), "group".to_string(), "val".to_string()];
        let rows = vec![
            vec!["A".to_string(), "x".to_string(), "10".to_string()],
            vec!["A".to_string(), "y".to_string(), "5".to_string()],
            vec!["B".to_string(), "x".to_string(), "7".to_string()],
            vec!["B".to_string(), "y".to_string(), "3".to_string()],
        ];

        println!("Columns: {:?}", columns);
        println!("Rows: {:?}", rows);

        // Create dataframe
        let df = match from_rows(&columns, &rows) {
            Ok(df) => {
                println!("✅ DataFrame created successfully");
                df
            }
            Err(e) => {
                println!("❌ Failed to create dataframe: {:?}", e);
                std::process::exit(1);
            }
        };

        // Convert to JSON
        let json = match to_json(df) {
            Ok(json) => {
                println!("✅ JSON conversion successful");
                json
            }
            Err(e) => {
                println!("❌ Failed to convert to JSON: {:?}", e);
                std::process::exit(1);
            }
        };

        // Show result
        println!("JSON result: {}", json);

        // Basic validation
        if json.starts_with("[") && json.contains("A") {
            println!("✅ Test 1 passed: Basic dataframe operations work");
        } else {
            println!("❌ Test 1 failed: Invalid JSON output");
            std::process::exit(1);
        }

        // Test 2: Filter (val > 5) via interface, then Aggregation::Count
        println!("\nTest 2: Interface filter(val > 5) then Aggregation::Count...");
        // Fresh dataframe
        let df2 = match from_rows(&columns, &rows) {
            Ok(df) => df,
            Err(e) => {
                println!("❌ Failed to create dataframe for filter+agg: {:?}", e);
                std::process::exit(1);
            }
        };
        let filters = vec![ColumnFilter {
            column: "val".to_string(),
            op: Comparator::Gt,
            value: Scalar::Value(5.0),
        }];
        let df_filtered = match filter(df2, &filters) {
            Ok(df) => df,
            Err(()) => {
                println!("❌ filter(val > 5) returned error");
                std::process::exit(1);
            }
        };
        let aggs = vec![Aggregation::Count];
        let agg_df = match aggregate(df_filtered, &aggs) {
            Ok(df) => df,
            Err(()) => {
                println!("❌ aggregate(count) after filter returned error");
                std::process::exit(1);
            }
        };
        let agg_json = match to_json(agg_df) {
            Ok(s) => s,
            Err(()) => {
                println!("❌ Failed to to_json aggregated dataframe");
                std::process::exit(1);
            }
        };
        println!("Filter+Aggregation result JSON: {}", agg_json);
        if !agg_json.contains("count") {
            println!("❌ Aggregation output missing 'count' field");
            std::process::exit(1);
        }
        println!("✅ Interface filter + Aggregation::Count test passed");


        Ok(())
    }
}

bindings::export!(Component with_types_in bindings);
