// Generated by `wit-bindgen` 0.41.0. DO NOT EDIT!
// Options used:
//   * runtime_path: "wit_bindgen_rt"
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_run_matrix_example_cabi<T: Guest>() -> *mut u8 {
    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
    let result0 = T::run_matrix_example();
    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
    match result0 {
        Ok(_) => {
            *ptr1.add(0).cast::<u8>() = (0i32) as u8;
        }
        Err(e) => {
            *ptr1.add(0).cast::<u8>() = (1i32) as u8;
            let vec2 = (e.into_bytes()).into_boxed_slice();
            let ptr2 = vec2.as_ptr().cast::<u8>();
            let len2 = vec2.len();
            ::core::mem::forget(vec2);
            *ptr1.add(2 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len2;
            *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr2
                .cast_mut();
        }
    };
    ptr1
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn __post_return_run_matrix_example<T: Guest>(arg0: *mut u8) {
    let l0 = i32::from(*arg0.add(0).cast::<u8>());
    match l0 {
        0 => {}
        _ => {
            let l1 = *arg0.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
            let l2 = *arg0.add(2 * ::core::mem::size_of::<*const u8>()).cast::<usize>();
            _rt::cabi_dealloc(l1, l2, 1);
        }
    }
}
pub trait Guest {
    fn run_matrix_example() -> Result<(), _rt::String>;
}
#[doc(hidden)]
macro_rules! __export_world_client_cabi {
    ($ty:ident with_types_in $($path_to_types:tt)*) => {
        const _ : () = { #[unsafe (export_name = "run-matrix-example")] unsafe extern "C"
        fn export_run_matrix_example() -> * mut u8 { unsafe { $($path_to_types)*::
        _export_run_matrix_example_cabi::<$ty > () } } #[unsafe (export_name =
        "cabi_post_run-matrix-example")] unsafe extern "C" fn
        _post_return_run_matrix_example(arg0 : * mut u8,) { unsafe { $($path_to_types)*::
        __post_return_run_matrix_example::<$ty > (arg0) } } };
    };
}
#[doc(hidden)]
pub(crate) use __export_world_client_cabi;
#[cfg_attr(target_pointer_width = "64", repr(align(8)))]
#[cfg_attr(target_pointer_width = "32", repr(align(4)))]
struct _RetArea([::core::mem::MaybeUninit<u8>; 3 * ::core::mem::size_of::<*const u8>()]);
static mut _RET_AREA: _RetArea = _RetArea(
    [::core::mem::MaybeUninit::uninit(); 3 * ::core::mem::size_of::<*const u8>()],
);
#[rustfmt::skip]
#[allow(dead_code, clippy::all)]
pub mod wasi {
    pub mod accelerator {
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod host_allocator {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            pub type Handle = u32;
            #[derive(Clone)]
            pub enum HostError {
                InvalidHandle,
                AllocationFailed,
                CopyOutOfBounds,
                ComputationError(_rt::String),
                DimensionMismatch,
                Other(_rt::String),
            }
            impl ::core::fmt::Debug for HostError {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        HostError::InvalidHandle => {
                            f.debug_tuple("HostError::InvalidHandle").finish()
                        }
                        HostError::AllocationFailed => {
                            f.debug_tuple("HostError::AllocationFailed").finish()
                        }
                        HostError::CopyOutOfBounds => {
                            f.debug_tuple("HostError::CopyOutOfBounds").finish()
                        }
                        HostError::ComputationError(e) => {
                            f.debug_tuple("HostError::ComputationError")
                                .field(e)
                                .finish()
                        }
                        HostError::DimensionMismatch => {
                            f.debug_tuple("HostError::DimensionMismatch").finish()
                        }
                        HostError::Other(e) => {
                            f.debug_tuple("HostError::Other").field(e).finish()
                        }
                    }
                }
            }
            impl ::core::fmt::Display for HostError {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    write!(f, "{:?}", self)
                }
            }
            impl std::error::Error for HostError {}
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct MatrixDimensions {
                pub rows: u32,
                pub cols: u32,
            }
            impl ::core::fmt::Debug for MatrixDimensions {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("MatrixDimensions")
                        .field("rows", &self.rows)
                        .field("cols", &self.cols)
                        .finish()
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn allocate_buffer(size: u64) -> Result<Handle, HostError> {
                unsafe {
                    #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                    #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 4 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 4
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(
                        wasm_import_module = "wasi:accelerator/host-allocator@0.2.0-draft"
                    )]
                    unsafe extern "C" {
                        #[link_name = "allocate-buffer"]
                        fn wit_import1(_: i64, _: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: i64, _: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import1(_rt::as_i64(&size), ptr0) };
                    let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                    let result12 = match l2 {
                        0 => {
                            let e = {
                                let l3 = *ptr0
                                    .add(::core::mem::size_of::<*const u8>())
                                    .cast::<i32>();
                                l3 as u32
                            };
                            Ok(e)
                        }
                        1 => {
                            let e = {
                                let l4 = i32::from(
                                    *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                                );
                                let v11 = match l4 {
                                    0 => HostError::InvalidHandle,
                                    1 => HostError::AllocationFailed,
                                    2 => HostError::CopyOutOfBounds,
                                    3 => {
                                        let e11 = {
                                            let l5 = *ptr0
                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>();
                                            let l6 = *ptr0
                                                .add(3 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>();
                                            let len7 = l6;
                                            let bytes7 = _rt::Vec::from_raw_parts(
                                                l5.cast(),
                                                len7,
                                                len7,
                                            );
                                            _rt::string_lift(bytes7)
                                        };
                                        HostError::ComputationError(e11)
                                    }
                                    4 => HostError::DimensionMismatch,
                                    n => {
                                        debug_assert_eq!(n, 5, "invalid enum discriminant");
                                        let e11 = {
                                            let l8 = *ptr0
                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>();
                                            let l9 = *ptr0
                                                .add(3 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>();
                                            let len10 = l9;
                                            let bytes10 = _rt::Vec::from_raw_parts(
                                                l8.cast(),
                                                len10,
                                                len10,
                                            );
                                            _rt::string_lift(bytes10)
                                        };
                                        HostError::Other(e11)
                                    }
                                };
                                v11
                            };
                            Err(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    };
                    result12
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn free_buffer(h: Handle) -> Result<(), HostError> {
                unsafe {
                    #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                    #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 4 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 4
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(
                        wasm_import_module = "wasi:accelerator/host-allocator@0.2.0-draft"
                    )]
                    unsafe extern "C" {
                        #[link_name = "free-buffer"]
                        fn wit_import1(_: i32, _: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import1(_rt::as_i32(h), ptr0) };
                    let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                    let result11 = match l2 {
                        0 => {
                            let e = ();
                            Ok(e)
                        }
                        1 => {
                            let e = {
                                let l3 = i32::from(
                                    *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                                );
                                let v10 = match l3 {
                                    0 => HostError::InvalidHandle,
                                    1 => HostError::AllocationFailed,
                                    2 => HostError::CopyOutOfBounds,
                                    3 => {
                                        let e10 = {
                                            let l4 = *ptr0
                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>();
                                            let l5 = *ptr0
                                                .add(3 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>();
                                            let len6 = l5;
                                            let bytes6 = _rt::Vec::from_raw_parts(
                                                l4.cast(),
                                                len6,
                                                len6,
                                            );
                                            _rt::string_lift(bytes6)
                                        };
                                        HostError::ComputationError(e10)
                                    }
                                    4 => HostError::DimensionMismatch,
                                    n => {
                                        debug_assert_eq!(n, 5, "invalid enum discriminant");
                                        let e10 = {
                                            let l7 = *ptr0
                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>();
                                            let l8 = *ptr0
                                                .add(3 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>();
                                            let len9 = l8;
                                            let bytes9 = _rt::Vec::from_raw_parts(
                                                l7.cast(),
                                                len9,
                                                len9,
                                            );
                                            _rt::string_lift(bytes9)
                                        };
                                        HostError::Other(e10)
                                    }
                                };
                                v10
                            };
                            Err(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    };
                    result11
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn write_to_host(
                guest_bytes: &[u8],
                target_handle: Handle,
                target_offset: u64,
            ) -> Result<(), HostError> {
                unsafe {
                    #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                    #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 4 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 4
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let vec0 = guest_bytes;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(
                        wasm_import_module = "wasi:accelerator/host-allocator@0.2.0-draft"
                    )]
                    unsafe extern "C" {
                        #[link_name = "write-to-host"]
                        fn wit_import2(_: *mut u8, _: usize, _: i32, _: i64, _: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import2(
                        _: *mut u8,
                        _: usize,
                        _: i32,
                        _: i64,
                        _: *mut u8,
                    ) {
                        unreachable!()
                    }
                    unsafe {
                        wit_import2(
                            ptr0.cast_mut(),
                            len0,
                            _rt::as_i32(target_handle),
                            _rt::as_i64(&target_offset),
                            ptr1,
                        )
                    };
                    let l3 = i32::from(*ptr1.add(0).cast::<u8>());
                    let result12 = match l3 {
                        0 => {
                            let e = ();
                            Ok(e)
                        }
                        1 => {
                            let e = {
                                let l4 = i32::from(
                                    *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                                );
                                let v11 = match l4 {
                                    0 => HostError::InvalidHandle,
                                    1 => HostError::AllocationFailed,
                                    2 => HostError::CopyOutOfBounds,
                                    3 => {
                                        let e11 = {
                                            let l5 = *ptr1
                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>();
                                            let l6 = *ptr1
                                                .add(3 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>();
                                            let len7 = l6;
                                            let bytes7 = _rt::Vec::from_raw_parts(
                                                l5.cast(),
                                                len7,
                                                len7,
                                            );
                                            _rt::string_lift(bytes7)
                                        };
                                        HostError::ComputationError(e11)
                                    }
                                    4 => HostError::DimensionMismatch,
                                    n => {
                                        debug_assert_eq!(n, 5, "invalid enum discriminant");
                                        let e11 = {
                                            let l8 = *ptr1
                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>();
                                            let l9 = *ptr1
                                                .add(3 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>();
                                            let len10 = l9;
                                            let bytes10 = _rt::Vec::from_raw_parts(
                                                l8.cast(),
                                                len10,
                                                len10,
                                            );
                                            _rt::string_lift(bytes10)
                                        };
                                        HostError::Other(e11)
                                    }
                                };
                                v11
                            };
                            Err(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    };
                    result12
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn read_from_host(
                source_handle: Handle,
                source_offset: u64,
                len: u64,
            ) -> Result<_rt::Vec<u8>, HostError> {
                unsafe {
                    #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                    #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 4 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 4
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(
                        wasm_import_module = "wasi:accelerator/host-allocator@0.2.0-draft"
                    )]
                    unsafe extern "C" {
                        #[link_name = "read-from-host"]
                        fn wit_import1(_: i32, _: i64, _: i64, _: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(
                        _: i32,
                        _: i64,
                        _: i64,
                        _: *mut u8,
                    ) {
                        unreachable!()
                    }
                    unsafe {
                        wit_import1(
                            _rt::as_i32(source_handle),
                            _rt::as_i64(&source_offset),
                            _rt::as_i64(&len),
                            ptr0,
                        )
                    };
                    let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                    let result14 = match l2 {
                        0 => {
                            let e = {
                                let l3 = *ptr0
                                    .add(::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>();
                                let l4 = *ptr0
                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>();
                                let len5 = l4;
                                _rt::Vec::from_raw_parts(l3.cast(), len5, len5)
                            };
                            Ok(e)
                        }
                        1 => {
                            let e = {
                                let l6 = i32::from(
                                    *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                                );
                                let v13 = match l6 {
                                    0 => HostError::InvalidHandle,
                                    1 => HostError::AllocationFailed,
                                    2 => HostError::CopyOutOfBounds,
                                    3 => {
                                        let e13 = {
                                            let l7 = *ptr0
                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>();
                                            let l8 = *ptr0
                                                .add(3 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>();
                                            let len9 = l8;
                                            let bytes9 = _rt::Vec::from_raw_parts(
                                                l7.cast(),
                                                len9,
                                                len9,
                                            );
                                            _rt::string_lift(bytes9)
                                        };
                                        HostError::ComputationError(e13)
                                    }
                                    4 => HostError::DimensionMismatch,
                                    n => {
                                        debug_assert_eq!(n, 5, "invalid enum discriminant");
                                        let e13 = {
                                            let l10 = *ptr0
                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>();
                                            let l11 = *ptr0
                                                .add(3 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>();
                                            let len12 = l11;
                                            let bytes12 = _rt::Vec::from_raw_parts(
                                                l10.cast(),
                                                len12,
                                                len12,
                                            );
                                            _rt::string_lift(bytes12)
                                        };
                                        HostError::Other(e13)
                                    }
                                };
                                v13
                            };
                            Err(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    };
                    result14
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// We need a way to associate dimensions with a handle when it's created or written to.
            /// Let's add an explicit function for the provider to register dimensions
            /// after data is written, or make allocate_buffer more specific if it's for matrices.
            /// For now, let's add `register-matrix-dimensions`
            pub fn register_matrix_dimensions(
                h: Handle,
                dims: MatrixDimensions,
            ) -> Result<(), HostError> {
                unsafe {
                    #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                    #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 4 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 4
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let MatrixDimensions { rows: rows0, cols: cols0 } = dims;
                    let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(
                        wasm_import_module = "wasi:accelerator/host-allocator@0.2.0-draft"
                    )]
                    unsafe extern "C" {
                        #[link_name = "register-matrix-dimensions"]
                        fn wit_import2(_: i32, _: i32, _: i32, _: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import2(
                        _: i32,
                        _: i32,
                        _: i32,
                        _: *mut u8,
                    ) {
                        unreachable!()
                    }
                    unsafe {
                        wit_import2(
                            _rt::as_i32(h),
                            _rt::as_i32(rows0),
                            _rt::as_i32(cols0),
                            ptr1,
                        )
                    };
                    let l3 = i32::from(*ptr1.add(0).cast::<u8>());
                    let result12 = match l3 {
                        0 => {
                            let e = ();
                            Ok(e)
                        }
                        1 => {
                            let e = {
                                let l4 = i32::from(
                                    *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                                );
                                let v11 = match l4 {
                                    0 => HostError::InvalidHandle,
                                    1 => HostError::AllocationFailed,
                                    2 => HostError::CopyOutOfBounds,
                                    3 => {
                                        let e11 = {
                                            let l5 = *ptr1
                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>();
                                            let l6 = *ptr1
                                                .add(3 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>();
                                            let len7 = l6;
                                            let bytes7 = _rt::Vec::from_raw_parts(
                                                l5.cast(),
                                                len7,
                                                len7,
                                            );
                                            _rt::string_lift(bytes7)
                                        };
                                        HostError::ComputationError(e11)
                                    }
                                    4 => HostError::DimensionMismatch,
                                    n => {
                                        debug_assert_eq!(n, 5, "invalid enum discriminant");
                                        let e11 = {
                                            let l8 = *ptr1
                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>();
                                            let l9 = *ptr1
                                                .add(3 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>();
                                            let len10 = l9;
                                            let bytes10 = _rt::Vec::from_raw_parts(
                                                l8.cast(),
                                                len10,
                                                len10,
                                            );
                                            _rt::string_lift(bytes10)
                                        };
                                        HostError::Other(e11)
                                    }
                                };
                                v11
                            };
                            Err(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    };
                    result12
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn matrix_multiply_f32(
                handle_a: Handle,
                handle_b: Handle,
            ) -> Result<Handle, HostError> {
                unsafe {
                    #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                    #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 4 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 4
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(
                        wasm_import_module = "wasi:accelerator/host-allocator@0.2.0-draft"
                    )]
                    unsafe extern "C" {
                        #[link_name = "matrix-multiply-f32"]
                        fn wit_import1(_: i32, _: i32, _: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: i32, _: i32, _: *mut u8) {
                        unreachable!()
                    }
                    unsafe {
                        wit_import1(_rt::as_i32(handle_a), _rt::as_i32(handle_b), ptr0)
                    };
                    let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                    let result12 = match l2 {
                        0 => {
                            let e = {
                                let l3 = *ptr0
                                    .add(::core::mem::size_of::<*const u8>())
                                    .cast::<i32>();
                                l3 as u32
                            };
                            Ok(e)
                        }
                        1 => {
                            let e = {
                                let l4 = i32::from(
                                    *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                                );
                                let v11 = match l4 {
                                    0 => HostError::InvalidHandle,
                                    1 => HostError::AllocationFailed,
                                    2 => HostError::CopyOutOfBounds,
                                    3 => {
                                        let e11 = {
                                            let l5 = *ptr0
                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>();
                                            let l6 = *ptr0
                                                .add(3 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>();
                                            let len7 = l6;
                                            let bytes7 = _rt::Vec::from_raw_parts(
                                                l5.cast(),
                                                len7,
                                                len7,
                                            );
                                            _rt::string_lift(bytes7)
                                        };
                                        HostError::ComputationError(e11)
                                    }
                                    4 => HostError::DimensionMismatch,
                                    n => {
                                        debug_assert_eq!(n, 5, "invalid enum discriminant");
                                        let e11 = {
                                            let l8 = *ptr0
                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>();
                                            let l9 = *ptr0
                                                .add(3 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>();
                                            let len10 = l9;
                                            let bytes10 = _rt::Vec::from_raw_parts(
                                                l8.cast(),
                                                len10,
                                                len10,
                                            );
                                            _rt::string_lift(bytes10)
                                        };
                                        HostError::Other(e11)
                                    }
                                };
                                v11
                            };
                            Err(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    };
                    result12
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn get_matrix_dimensions(
                h: Handle,
            ) -> Result<MatrixDimensions, HostError> {
                unsafe {
                    #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                    #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 4 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 4
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(
                        wasm_import_module = "wasi:accelerator/host-allocator@0.2.0-draft"
                    )]
                    unsafe extern "C" {
                        #[link_name = "get-matrix-dimensions"]
                        fn wit_import1(_: i32, _: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import1(_rt::as_i32(h), ptr0) };
                    let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                    let result13 = match l2 {
                        0 => {
                            let e = {
                                let l3 = *ptr0
                                    .add(::core::mem::size_of::<*const u8>())
                                    .cast::<i32>();
                                let l4 = *ptr0
                                    .add(4 + 1 * ::core::mem::size_of::<*const u8>())
                                    .cast::<i32>();
                                MatrixDimensions {
                                    rows: l3 as u32,
                                    cols: l4 as u32,
                                }
                            };
                            Ok(e)
                        }
                        1 => {
                            let e = {
                                let l5 = i32::from(
                                    *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                                );
                                let v12 = match l5 {
                                    0 => HostError::InvalidHandle,
                                    1 => HostError::AllocationFailed,
                                    2 => HostError::CopyOutOfBounds,
                                    3 => {
                                        let e12 = {
                                            let l6 = *ptr0
                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>();
                                            let l7 = *ptr0
                                                .add(3 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>();
                                            let len8 = l7;
                                            let bytes8 = _rt::Vec::from_raw_parts(
                                                l6.cast(),
                                                len8,
                                                len8,
                                            );
                                            _rt::string_lift(bytes8)
                                        };
                                        HostError::ComputationError(e12)
                                    }
                                    4 => HostError::DimensionMismatch,
                                    n => {
                                        debug_assert_eq!(n, 5, "invalid enum discriminant");
                                        let e12 = {
                                            let l9 = *ptr0
                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>();
                                            let l10 = *ptr0
                                                .add(3 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>();
                                            let len11 = l10;
                                            let bytes11 = _rt::Vec::from_raw_parts(
                                                l9.cast(),
                                                len11,
                                                len11,
                                            );
                                            _rt::string_lift(bytes11)
                                        };
                                        HostError::Other(e12)
                                    }
                                };
                                v12
                            };
                            Err(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    };
                    result13
                }
            }
        }
    }
}
#[rustfmt::skip]
mod _rt {
    #![allow(dead_code, clippy::all)]
    pub use alloc_crate::string::String;
    pub fn as_i64<T: AsI64>(t: T) -> i64 {
        t.as_i64()
    }
    pub trait AsI64 {
        fn as_i64(self) -> i64;
    }
    impl<'a, T: Copy + AsI64> AsI64 for &'a T {
        fn as_i64(self) -> i64 {
            (*self).as_i64()
        }
    }
    impl AsI64 for i64 {
        #[inline]
        fn as_i64(self) -> i64 {
            self as i64
        }
    }
    impl AsI64 for u64 {
        #[inline]
        fn as_i64(self) -> i64 {
            self as i64
        }
    }
    pub use alloc_crate::vec::Vec;
    pub unsafe fn string_lift(bytes: Vec<u8>) -> String {
        if cfg!(debug_assertions) {
            String::from_utf8(bytes).unwrap()
        } else {
            String::from_utf8_unchecked(bytes)
        }
    }
    pub unsafe fn invalid_enum_discriminant<T>() -> T {
        if cfg!(debug_assertions) {
            panic!("invalid enum discriminant")
        } else {
            unsafe { core::hint::unreachable_unchecked() }
        }
    }
    pub fn as_i32<T: AsI32>(t: T) -> i32 {
        t.as_i32()
    }
    pub trait AsI32 {
        fn as_i32(self) -> i32;
    }
    impl<'a, T: Copy + AsI32> AsI32 for &'a T {
        fn as_i32(self) -> i32 {
            (*self).as_i32()
        }
    }
    impl AsI32 for i32 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u32 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for i16 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u16 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for i8 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u8 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for char {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for usize {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    #[cfg(target_arch = "wasm32")]
    pub fn run_ctors_once() {
        wit_bindgen_rt::run_ctors_once();
    }
    pub unsafe fn cabi_dealloc(ptr: *mut u8, size: usize, align: usize) {
        if size == 0 {
            return;
        }
        let layout = alloc::Layout::from_size_align_unchecked(size, align);
        alloc::dealloc(ptr, layout);
    }
    extern crate alloc as alloc_crate;
    pub use alloc_crate::alloc;
}
/// Generates `#[unsafe(no_mangle)]` functions to export the specified type as
/// the root implementation of all generated traits.
///
/// For more information see the documentation of `wit_bindgen::generate!`.
///
/// ```rust
/// # macro_rules! export{ ($($t:tt)*) => (); }
/// # trait Guest {}
/// struct MyType;
///
/// impl Guest for MyType {
///     // ...
/// }
///
/// export!(MyType);
/// ```
#[allow(unused_macros)]
#[doc(hidden)]
macro_rules! __export_client_impl {
    ($ty:ident) => {
        self::export!($ty with_types_in self);
    };
    ($ty:ident with_types_in $($path_to_types_root:tt)*) => {
        $($path_to_types_root)*:: __export_world_client_cabi!($ty with_types_in
        $($path_to_types_root)*);
    };
}
#[doc(inline)]
pub(crate) use __export_client_impl as export;
#[cfg(target_arch = "wasm32")]
#[unsafe(
    link_section = "component-type:wit-bindgen:0.41.0:my-org:matrix-client-world@0.1.0:client:encoded world"
)]
#[doc(hidden)]
#[allow(clippy::octal_escapes)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 773] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\x88\x05\x01A\x02\x01\
A\x05\x01B\x19\x01y\x04\0\x06handle\x03\0\0\x01q\x06\x0einvalid-handle\0\0\x11al\
location-failed\0\0\x12copy-out-of-bounds\0\0\x11computation-error\x01s\0\x12dim\
ension-mismatch\0\0\x05other\x01s\0\x04\0\x0ahost-error\x03\0\x02\x01r\x02\x04ro\
wsy\x04colsy\x04\0\x11matrix-dimensions\x03\0\x04\x01j\x01\x01\x01\x03\x01@\x01\x04\
sizew\0\x06\x04\0\x0fallocate-buffer\x01\x07\x01j\0\x01\x03\x01@\x01\x01h\x01\0\x08\
\x04\0\x0bfree-buffer\x01\x09\x01p}\x01@\x03\x0bguest-bytes\x0a\x0dtarget-handle\
\x01\x0dtarget-offsetw\0\x08\x04\0\x0dwrite-to-host\x01\x0b\x01j\x01\x0a\x01\x03\
\x01@\x03\x0dsource-handle\x01\x0dsource-offsetw\x03lenw\0\x0c\x04\0\x0eread-fro\
m-host\x01\x0d\x01@\x02\x01h\x01\x04dims\x05\0\x08\x04\0\x1aregister-matrix-dime\
nsions\x01\x0e\x01@\x02\x08handle-a\x01\x08handle-b\x01\0\x06\x04\0\x13matrix-mu\
ltiply-f32\x01\x0f\x01j\x01\x05\x01\x03\x01@\x01\x01h\x01\0\x10\x04\0\x15get-mat\
rix-dimensions\x01\x11\x03\0+wasi:accelerator/host-allocator@0.2.0-draft\x05\0\x01\
j\0\x01s\x01@\0\0\x01\x04\0\x12run-matrix-example\x01\x02\x04\0'my-org:matrix-cl\
ient-world/client@0.1.0\x04\0\x0b\x0c\x01\0\x06client\x03\0\0\0G\x09producers\x01\
\x0cprocessed-by\x02\x0dwit-component\x070.227.1\x10wit-bindgen-rust\x060.41.0";
#[inline(never)]
#[doc(hidden)]
pub fn __link_custom_section_describing_imports() {
    wit_bindgen_rt::maybe_link_cabi_realloc();
}
